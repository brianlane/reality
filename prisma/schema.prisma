// schema.prisma
// Reality Matchmaking Database Schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
  // Note: directUrl uses the direct connection (non-pooled) for migrations
  // Falls back to DATABASE_URL in CI environments where only DATABASE_URL is set
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum UserRole {
  APPLICANT
  ADMIN
}

model User {
  id            String   @id @default(cuid())
  clerkId       String   @unique // Clerk user ID
  email         String   @unique
  firstName     String
  lastName      String
  phone         String?
  role          UserRole @default(APPLICANT)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?
  deletedBy     String?
  
  applicant     Applicant?
  adminActions  AdminAction[]
  
  @@index([email])
  @@index([clerkId])
  @@index([deletedAt])
}

// ============================================
// APPLICATION & SCREENING
// ============================================

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  PAYMENT_PENDING
  SCREENING_IN_PROGRESS
  APPROVED
  REJECTED
  WAITLIST
  WAITLIST_INVITED
  RESEARCH_INVITED
  RESEARCH_IN_PROGRESS
  RESEARCH_COMPLETED
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum ScreeningStatus {
  PENDING
  IN_PROGRESS
  PASSED
  FAILED
}

model Applicant {
  id                    String            @id @default(cuid())
  userId                String            @unique
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Demographics
  age                   Int
  gender                Gender
  seeking               Gender?
  location              String
  cityFrom              String?
  industry              String?
  occupation            String
  employer              String?
  education             String
  incomeRange           String
  incomeVerified        Boolean           @default(false)
  referredBy            String?
  aboutYourself         String?           @db.Text

  // Stage 1 Qualification
  stage1CompletedAt     DateTime?
  stage1Responses       Json?             // Store minimal qualification data

  // Waitlist Management
  waitlistedAt          DateTime?
  waitlistReason        String?           // Admin's reason for keeping on waitlist
  waitlistPosition      Int?              // Optional: queue position
  invitedOffWaitlistAt  DateTime?
  invitedOffWaitlistBy  String?           // Admin user ID
  waitlistInviteToken   String?   @unique // Unique token for invite link

  // Research Invite Flow
  researchInviteCode    String?   @unique
  researchInvitedAt     DateTime?
  researchInvitedBy     String?           // Admin user ID
  researchInviteUsedAt  DateTime?
  researchCompletedAt   DateTime?

  // Application Status
  applicationStatus     ApplicationStatus @default(DRAFT)
  submittedAt           DateTime?
  reviewedAt            DateTime?
  reviewedBy            String?           // Admin user ID
  rejectionReason       String?
  softRejectedAt        DateTime?
  softRejectedFromStatus ApplicationStatus?
  
  // Screening - CRITICAL: Only store pass/fail status
  screeningStatus       ScreeningStatus   @default(PENDING)
  idenfyStatus          ScreeningStatus   @default(PENDING)
  idenfyVerificationId  String?           @unique
  checkrStatus          ScreeningStatus   @default(PENDING)
  checkrReportId        String?           @unique
  backgroundCheckNotes  String?           // General notes, NOT sensitive data
  
  // Compatibility & Matching
  compatibilityScore    Float?            // 0-100 calculated score
  
  // Profile Photos (URLs only)
  photos                String[]          // Array of Supabase Storage URLs
  
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  deletedAt             DateTime?
  deletedBy             String?
  
  questionnaire         Questionnaire?
  questionnaireAnswers  QuestionnaireAnswer[]
  payments              Payment[]
  eventInvitations      EventInvitation[]
  matches               Match[]           @relation("ApplicantMatches")
  matchesAsPartner      Match[]           @relation("PartnerMatches")
  emailLogs             EmailLog[]

  @@index([applicationStatus])
  @@index([gender])
  @@index([screeningStatus])
  @@index([compatibilityScore])
  @@index([deletedAt])
}

enum QuestionnaireQuestionType {
  TEXT
  TEXTAREA
  RICH_TEXT
  DROPDOWN
  RADIO_7
  CHECKBOXES
  NUMBER_SCALE
}

model QuestionnairePage {
  id          String                  @id @default(cuid())
  title       String
  description String?                 @db.Text
  order       Int                     @default(0)
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt
  deletedAt   DateTime?
  deletedBy   String?

  sections    QuestionnaireSection[]

  @@index([order])
  @@index([deletedAt])
}

model QuestionnaireSection {
  id          String                  @id @default(cuid())
  title       String
  description String?                 @db.Text
  order       Int                     @default(0)
  isActive    Boolean                 @default(true)
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt
  deletedAt   DateTime?
  deletedBy   String?
  pageId      String?

  page        QuestionnairePage?      @relation(fields: [pageId], references: [id], onDelete: Cascade)
  questions   QuestionnaireQuestion[]

  @@index([order])
  @@index([isActive])
  @@index([deletedAt])
  @@index([pageId])
}

model QuestionnaireQuestion {
  id         String                    @id @default(cuid())
  sectionId  String
  section    QuestionnaireSection      @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  prompt     String
  helperText String?
  type       QuestionnaireQuestionType
  options    Json?
  isRequired Boolean                   @default(false)
  order      Int                       @default(0)
  isActive   Boolean                   @default(true)

  // Compatibility scoring metadata
  mlWeight      Float                   @default(1.0)  // 0.0-1.0 importance weight
  isDealbreaker Boolean                 @default(false) // If mismatch, score = 0

  createdAt  DateTime                  @default(now())
  updatedAt  DateTime                  @updatedAt
  deletedAt  DateTime?
  deletedBy  String?

  answers    QuestionnaireAnswer[]

  @@index([sectionId])
  @@index([type])
  @@index([order])
  @@index([isActive])
  @@index([deletedAt])
}

model QuestionnaireAnswer {
  id          String                @id @default(cuid())
  applicantId String
  applicant   Applicant             @relation(fields: [applicantId], references: [id], onDelete: Cascade)
  questionId  String
  question    QuestionnaireQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  value       Json?
  richText    String?               @db.Text
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  @@unique([applicantId, questionId])
  @@index([applicantId])
  @@index([questionId])
}

model Questionnaire {
  id            String    @id @default(cuid())
  applicantId   String    @unique
  applicant     Applicant @relation(fields: [applicantId], references: [id], onDelete: Cascade)
  
  // Values & Beliefs (scored 1-5)
  religionImportance      Int
  politicalAlignment      String
  familyImportance        Int
  careerAmbition          Int
  financialGoals          String
  
  // Lifestyle
  fitnessLevel            String
  diet                    String
  drinking                String
  smoking                 String
  drugs                   String
  pets                    String
  
  // Relationship Goals
  relationshipGoal        String    // Marriage, Long-term, etc.
  wantsChildren           String    // Yes, No, Maybe, Already have
  childrenTimeline        String?
  movingWillingness       String
  
  // Interests & Hobbies
  hobbies                 String[]  // Array of interests
  travelFrequency         String
  favoriteActivities      String[]
  
  // Communication & Personality
  loveLanguage            String
  conflictStyle           String
  introvertExtrovert      Int       // 1-10 scale
  spontaneityPlanning     Int       // 1-10 scale
  
  // Deal-breakers
  dealBreakers            String[]
  
  // Open-ended
  aboutMe                 String    @db.Text
  idealPartner            String    @db.Text
  perfectDate             String    @db.Text
  
  // Raw JSON for flexibility
  responses               Json      // Full questionnaire responses
  
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
}

// ============================================
// PAYMENTS
// ============================================

enum PaymentType {
  APPLICATION_FEE
  EVENT_FEE
  MEMBERSHIP
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

model Payment {
  id                String        @id @default(cuid())
  applicantId       String
  applicant         Applicant     @relation(fields: [applicantId], references: [id])
  
  type              PaymentType
  amount            Int           // Amount in cents
  status            PaymentStatus @default(PENDING)
  
  stripePaymentId   String?       @unique
  stripeInvoiceId   String?
  
  eventId           String?       // If EVENT_FEE
  event             Event?        @relation(fields: [eventId], references: [id])
  
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  deletedAt         DateTime?
  deletedBy         String?
  
  @@index([applicantId])
  @@index([type])
  @@index([status])
  @@index([stripePaymentId])
  @@index([deletedAt])
}

// ============================================
// EVENTS
// ============================================

enum EventStatus {
  DRAFT
  INVITATIONS_SENT
  CONFIRMED
  COMPLETED
  CANCELLED
}

model Event {
  id                String            @id @default(cuid())
  name              String
  date              DateTime
  startTime         DateTime
  endTime           DateTime
  
  venue             String
  venueAddress      String
  capacity          Int               @default(20)
  
  status            EventStatus       @default(DRAFT)
  
  // Costs (in cents)
  venueCost         Int
  cateringCost      Int
  materialsCost     Int
  totalCost         Int
  
  // Revenue (in cents)
  expectedRevenue   Int
  actualRevenue     Int               @default(0)
  actualCost        Int               @default(0)

  // Notes
  notes             String?           @db.Text
  
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  createdBy         String            // Admin user ID
  deletedAt         DateTime?
  deletedBy         String?
  
  invitations       EventInvitation[]
  matches           Match[]
  payments          Payment[]
  
  @@index([date])
  @@index([status])
  @@index([createdBy])
  @@index([deletedAt])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  ATTENDED
  NO_SHOW
}

model EventInvitation {
  id              String            @id @default(cuid())
  eventId         String
  event           Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  applicantId     String
  applicant       Applicant         @relation(fields: [applicantId], references: [id])
  
  status          InvitationStatus  @default(PENDING)
  invitedAt       DateTime          @default(now())
  respondedAt     DateTime?
  
  // Speed dating notes (participant private)
  blindNotes      String?           @db.Text
  faceToFaceNotes String?           @db.Text
  
  // Interests indicated during event
  interestedIn    String[]          // Array of applicant IDs
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  @@unique([eventId, applicantId])
  @@index([eventId])
  @@index([applicantId])
  @@index([status])
}

// ============================================
// MATCHES
// ============================================

enum MatchType {
  CURATED         // Your pre-event matching
  MUTUAL_SPEED    // Both indicated interest during speed dating
  SOCIAL_HOUR     // Connected during social hour
}

enum MatchOutcome {
  PENDING
  FIRST_DATE_SCHEDULED
  FIRST_DATE_COMPLETED
  SECOND_DATE
  DATING
  RELATIONSHIP
  ENGAGED
  MARRIED
  NO_CONNECTION
  GHOSTED
}

model Match {
  id              String        @id @default(cuid())
  eventId         String
  event           Event         @relation(fields: [eventId], references: [id])
  
  applicantId     String
  applicant       Applicant     @relation(name: "ApplicantMatches", fields: [applicantId], references: [id])
  
  partnerId       String
  partner         Applicant     @relation(name: "PartnerMatches", fields: [partnerId], references: [id])
  
  type            MatchType
  
  // Compatibility from questionnaire
  compatibilityScore Float?

  // Outcome tracking
  outcome         MatchOutcome  @default(PENDING)

  // Detailed analytics data
  analytics       MatchAnalytics?

  // Contact exchange
  contactExchanged Boolean      @default(false)
  contactExchangedAt DateTime?
  
  // Follow-ups (JSON survey responses)
  day30FollowUp   Json?
  day90FollowUp   Json?
  month6FollowUp  Json?
  
  notes           String?       @db.Text
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  deletedAt       DateTime?
  deletedBy       String?
  
  @@unique([eventId, applicantId, partnerId])
  @@index([eventId])
  @@index([applicantId])
  @@index([partnerId])
  @@index([outcome])
  @@index([type])
  @@index([deletedAt])
}

// Track detailed match analytics for insights
model MatchAnalytics {
  id              String   @id @default(cuid())
  matchId         String   @unique
  match           Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  // Date outcome
  dateAccepted    Boolean?     // Did both agree to date?
  dateCompleted   Boolean?     // Did the date happen?
  dateCompletedAt DateTime?

  // Post-date feedback (1-5 stars)
  applicantRating    Int?      // Applicant's rating of partner
  applicantFeedback  String?   @db.Text
  partnerRating      Int?      // Partner's rating of applicant
  partnerFeedback    String?   @db.Text

  // Relationship tracking
  relationshipFormed Boolean   @default(false)
  relationshipStatus String?   // 'dating', 'exclusive', 'ended', etc.
  relationshipEndedAt DateTime?

  // Admin feedback
  adminRating     Int?          // Admin assessment (1-5)
  adminNotes      String?       @db.Text

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([matchId])
  @@index([dateAccepted])
  @@index([relationshipFormed])
}

// ============================================
// ADMIN & ANALYTICS
// ============================================

enum AdminActionType {
  APPROVE_APPLICATION
  REJECT_APPLICATION
  CREATE_EVENT
  SEND_INVITATIONS
  RECORD_MATCH
  UPDATE_MATCH_OUTCOME
  MANUAL_ADJUSTMENT
  INVITE_OFF_WAITLIST
  BATCH_INVITE_WAITLIST
  INVITE_RESEARCH
}

model AdminAction {
  id          String          @id @default(cuid())
  userId      String
  user        User            @relation(fields: [userId], references: [id])
  
  type        AdminActionType
  targetId    String          // ID of affected entity
  targetType  String          // "applicant", "event", "match"
  
  description String
  metadata    Json?           // Additional context
  
  createdAt   DateTime        @default(now())
  
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([targetId])
}

// ============================================
// EMAIL LOGGING
// ============================================

enum EmailStatus {
  SENT
  FAILED
  BOUNCED
  DELIVERED
  OPENED
  CLICKED
}

model EmailLog {
  id              String      @id @default(cuid())
  resendId        String?     // Resend's email ID
  recipientEmail  String
  emailType       String      // "WAITLIST_CONFIRMATION", "PAYMENT", etc.
  subject         String
  status          EmailStatus @default(SENT)
  sentAt          DateTime    @default(now())
  failureReason   String?     @db.Text

  // Relations
  applicantId     String?
  applicant       Applicant?  @relation(fields: [applicantId], references: [id], onDelete: SetNull)

  @@index([applicantId])
  @@index([emailType])
  @@index([status])
  @@index([sentAt])
  @@index([recipientEmail])
}
